#pragma once
#include <string>

enum class ErrorCode
{
	LEXER_UNKNOWN_TOKEN,
	LEXER_INVALID_NUMBER,
	LEXER_UNCLOSED_STRING,
	LEXER_OVERLONG_TOKEN,

    PARSER_UNEXPECTED_TOKEN,
    PARSER_UNEXPECTED_EOF,
    PARSER_TOKEN_STREAM_OVERFLOW,
    PARSER_EXPECTED_SEMICOLON,
    PARSER_EXPECTED_LPAREN,
    PARSER_EXPECTED_RPAREN,
    PARSER_EXPECTED_LBRACE,
    PARSER_EXPECTED_RBRACE,
    PARSER_EXPECTED_IDENTIFIER,
    PARSER_EXPECTED_TYPE_KEYWORD,
    PARSER_EXPECTED_ASSIGN,
    PARSER_EXPECTED_EXPRESSION,
    PARSER_INVALID_VAR_DECL,
    PARSER_VAR_DECL_MISSING_INITIALIZER,
    PARSER_ARRAY_DECL_INVALID_DIMENSION,
    PARSER_INVALID_FUNC_DECL,
    PARSER_INVALID_PARAM_LIST,
    PARSER_INVALID_ARG_LIST,
    PARSER_INVALID_IF_SYNTAX,
    PARSER_INVALID_ELSE_IF,
    PARSER_INVALID_ELSE,
    PARSER_INVALID_WHILE_SYNTAX,
    PARSER_INVALID_FOR_SYNTAX,
    PARSER_BREAK_OUTSIDE_LOOP,
    PARSER_CONTINUE_OUTSIDE_LOOP,
    PARSER_RETURN_OUTSIDE_FUNCTION,
    PARSER_MISSING_RETURN_VALUE,
    PARSER_RETURN_TYPE_MISMATCH,
    PARSER_INVALID_ASSIGN_LHS,
    PARSER_UNCLOSED_PAREN,
    PARSER_UNCLOSED_ARRAY_ACCESS,
    PARSER_TOO_MANY_ARRAY_DIMENSIONS,
    PARSER_INVALID_UNARY_EXPR,
    PARSER_INVALID_BINARY_EXPR,
    PARSER_INVALID_LITERAL,
    PARSER_INVALID_FUNCTION_CALL,
    PARSER_CALL_ARGUMENT_COUNT_MISMATCH,
    PARSER_INTERNAL_UNREACHABLE,
    PARSER_UNKNOWN_ERROR

};

inline std::string error_code_to_string(ErrorCode code)
{
    switch (code)
    {
    case ErrorCode::LEXER_UNKNOWN_TOKEN:
        return "LEXER_UNKNOWN_TOKEN";
    case ErrorCode::LEXER_INVALID_NUMBER:
        return "LEXER_INVALID_NUMBER";
    case ErrorCode::LEXER_UNCLOSED_STRING:
        return "LEXER_UNCLOSED_STRING";
    case ErrorCode::LEXER_OVERLONG_TOKEN:
        return "LEXER_OVERLONG_TOKEN";

    case ErrorCode::PARSER_UNEXPECTED_TOKEN:
        return "PARSER_UNEXPECTED_TOKEN";
    case ErrorCode::PARSER_UNEXPECTED_EOF:
        return "PARSER_UNEXPECTED_EOF";
    case ErrorCode::PARSER_TOKEN_STREAM_OVERFLOW:
        return "PARSER_TOKEN_STREAM_OVERFLOW";
    case ErrorCode::PARSER_EXPECTED_SEMICOLON:
        return "PARSER_EXPECTED_SEMICOLON";
    case ErrorCode::PARSER_EXPECTED_LPAREN:
        return "PARSER_EXPECTED_LPAREN";
    case ErrorCode::PARSER_EXPECTED_RPAREN:
        return "PARSER_EXPECTED_RPAREN";
    case ErrorCode::PARSER_EXPECTED_LBRACE:
        return "PARSER_EXPECTED_LBRACE";
    case ErrorCode::PARSER_EXPECTED_RBRACE:
        return "PARSER_EXPECTED_RBRACE";
    case ErrorCode::PARSER_EXPECTED_IDENTIFIER:
        return "PARSER_EXPECTED_IDENTIFIER";
    case ErrorCode::PARSER_EXPECTED_TYPE_KEYWORD:
        return "PARSER_EXPECTED_TYPE_KEYWORD";
    case ErrorCode::PARSER_EXPECTED_ASSIGN:
        return "PARSER_EXPECTED_ASSIGN";
    case ErrorCode::PARSER_EXPECTED_EXPRESSION:
        return "PARSER_EXPECTED_EXPRESSION";
    case ErrorCode::PARSER_INVALID_VAR_DECL:
        return "PARSER_INVALID_VAR_DECL";
    case ErrorCode::PARSER_VAR_DECL_MISSING_INITIALIZER:
        return "PARSER_VAR_DECL_MISSING_INITIALIZER";
    case ErrorCode::PARSER_ARRAY_DECL_INVALID_DIMENSION:
        return "PARSER_ARRAY_DECL_INVALID_DIMENSION";
    case ErrorCode::PARSER_INVALID_FUNC_DECL:
        return "PARSER_INVALID_FUNC_DECL";
    case ErrorCode::PARSER_INVALID_PARAM_LIST:
        return "PARSER_INVALID_PARAM_LIST";
    case ErrorCode::PARSER_INVALID_ARG_LIST:
        return "PARSER_INVALID_ARG_LIST";
    case ErrorCode::PARSER_INVALID_IF_SYNTAX:
        return "PARSER_INVALID_IF_SYNTAX";
    case ErrorCode::PARSER_INVALID_ELSE_IF:
        return "PARSER_INVALID_ELSE_IF";
    case ErrorCode::PARSER_INVALID_ELSE:
        return "PARSER_INVALID_ELSE";
    case ErrorCode::PARSER_INVALID_WHILE_SYNTAX:
        return "PARSER_INVALID_WHILE_SYNTAX";
    case ErrorCode::PARSER_INVALID_FOR_SYNTAX:
        return "PARSER_INVALID_FOR_SYNTAX";
    case ErrorCode::PARSER_BREAK_OUTSIDE_LOOP:
        return "PARSER_BREAK_OUTSIDE_LOOP";
    case ErrorCode::PARSER_CONTINUE_OUTSIDE_LOOP:
        return "PARSER_CONTINUE_OUTSIDE_LOOP";
    case ErrorCode::PARSER_RETURN_OUTSIDE_FUNCTION:
        return "PARSER_RETURN_OUTSIDE_FUNCTION";
    case ErrorCode::PARSER_MISSING_RETURN_VALUE:
        return "PARSER_MISSING_RETURN_VALUE";
    case ErrorCode::PARSER_RETURN_TYPE_MISMATCH:
        return "PARSER_RETURN_TYPE_MISMATCH";
    case ErrorCode::PARSER_INVALID_ASSIGN_LHS:
        return "PARSER_INVALID_ASSIGN_LHS";
    case ErrorCode::PARSER_UNCLOSED_PAREN:
        return "PARSER_UNCLOSED_PAREN";
    case ErrorCode::PARSER_UNCLOSED_ARRAY_ACCESS:
        return "PARSER_UNCLOSED_ARRAY_ACCESS";
    case ErrorCode::PARSER_TOO_MANY_ARRAY_DIMENSIONS:
        return "PARSER_TOO_MANY_ARRAY_DIMENSIONS";
    case ErrorCode::PARSER_INVALID_UNARY_EXPR:
        return "PARSER_INVALID_UNARY_EXPR";
    case ErrorCode::PARSER_INVALID_BINARY_EXPR:
        return "PARSER_INVALID_BINARY_EXPR";
    case ErrorCode::PARSER_INVALID_LITERAL:
        return "PARSER_INVALID_LITERAL";
    case ErrorCode::PARSER_INVALID_FUNCTION_CALL:
        return "PARSER_INVALID_FUNCTION_CALL";
    case ErrorCode::PARSER_CALL_ARGUMENT_COUNT_MISMATCH:
        return "PARSER_CALL_ARGUMENT_COUNT_MISMATCH";
    case ErrorCode::PARSER_INTERNAL_UNREACHABLE:
        return "PARSER_INTERNAL_UNREACHABLE";
    case ErrorCode::PARSER_UNKNOWN_ERROR:
        return "PARSER_UNKNOWN_ERROR";

    default:
        return "UNKNOWN_ERROR_CODE";
    }
}


